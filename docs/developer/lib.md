# Libraries

[‚Üê Back to Developer Documentation](../README.md)

## PyNomicle

`PyNomicle` is the Nomicle library for use in Python programs. It requires [Python 3](https://www.python.org/download/releases/3.0/) and the [cryptography](https://cryptography.io/en/latest/) Python package. You typically include in your script it like so (assuming you preserved the directory structure as it was when you downloaded it):

```python
from PyNomicle.nomicle import IdentityBlock
```

Currently, all functions provided by the library are contained within the `IdentityBlock` class.

### IdentityBlock

#### Properties

- `int bits`: The calculated difficulty target being used for this identity stored in compact form.
- `bytes blockHash`: First **8** bytes of the SHA256 checksum of the block. To verify the hash, use the `hash()` method and compare against the first 8 bytes from the checksum it returns.
- `int extraNonce`: Used in case `nonce` overflows.
- `bytes identifier`: The identity token hash. This is a SHA256 hexadecimal string.
- `int nonce`: A counter to be incremented for varying the block's hash when solving the proof-of-work.
- `EllipticCurvePublicKey publicKey`: The public key of the owner; can be verified by the signature.
- `bytes signature`: The DER-encoded signature of the full `blockHash` generated by the private key that owns this identity.
- `datetime timestampCreated`: Unix timestamp as seconds since 1970-01-01T00:00 UTC until the time that this identity was created.
- `datetime timestampUpdated`: Unix timestamp as seconds since 1970-01-01T00:00 UTC until the time that this identity was last updated.
- `int version`: The identity version number that this nomicle conforms to.

**For most intents and purposes, the properties of interest to most developers working with nomicles will be `publicKey` and `identifier`.**

#### Methods

##### `__init__(identifier=None, publicKey=None)`

The constructor takes two optional arguments. `identifier` is the string (in its plain text format; typically as chosen by the user) that this nomicle will be associated with.

`publicKey` can be an instance of [EllipticCurvePublicKey](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/) and will be the public key associated with the identifier in this nomicle.

Example:

```python
#!/usr/bin/env python3

from PyNomicle.nomicle import IdentityBlock
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec

# We're creating a fresh private key and a nomicle to go with it.
# Typically, you'd want to check if a Nomicle private key already exists
# on the filesystem and read that instead of creating a new one.
privateKey = ec.generate_private_key(ec.SECP256K1(), default_backend())

block = IdentityBlock(
    identifier="alice",
    publicKey=privateKey.public_key()
)
```

##### `@staticmethod compare(block1, block2)`

Can be used to compare the targets of two blocks. `block1` and `block2` must be instances of `IdentityBlock`. Returns 0 if both blocks were solved for the same difficulty, 1 if `block2` was solved for a higher difficulty than `block1`, or -1 if `block1` was solved for a higher difficulty than `block2`.

##### `@staticmethod deserialise(blockByteArray)`

Deserialises the bytes in `blockByteArray` and returns an `IdentityBlock` object.

##### `dump(path, privateKey=None)`

Saves the block to the disk location specified in `path`. If `privateKey` is set to an instance of [EllipticCurvePrivateKey](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/), that key will be used to sign the block before dumping it to the disk.

##### `hash()`

Computes and returns a byte array containing the SHA256 hash of the block.

##### `@staticmethod lowerTarget(bits)`

Lowers the target in `bits` and returns the new, lower (more difficult) target.

##### `@staticmethod read(path)`

Reads the nomicle file at the disk location specified in `path` and returns it as an `IdentityBlock` object.

##### `serialise(privateKey=None)`

Serialises the block into a byte array. If `privateKey` is set to an instance of [EllipticCurvePrivateKey](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/), that key will be used to sign the block and the signature will be included in the array.

##### `@staticmethod sign(blockHash, privateKey)`

Computes and returns an ECDSA signature of the byte array in `blockHash` using the private key in `privateKey`. Although the argument is called "blockHash", this method can be used to sign any kind of hash.

##### `unpackTarget()`

Unpacks the block's target from its compact form and returns the mantissa, exponent, and expanded target as a tuple. The tuple contains the following items in this order:

1. [0] Exponent
2. [1] Mantissa
3. [2] Expanded Target

---

## libcnomicle

`libcnomicle` is the Nomicle library for use in C/C++ programs. It requires the [OpenSSL development headers](https://wiki.openssl.org/index.php/Binaries). `libcnomicle` is currently an Xcode project that builds on macOS. The actual C source code, however, is compilable under Linux and Windows as well.

After building the library, two files will be of relevance: `libcnomicle.a` (or `libcnomicle.dll` on Windows) and `nomicle.h`. On Unix-like systems, `nomicle.h` should typically be in the `/usr/local/include/` directory. To use the library in your code, you need to link against the library you built as well as `libssl` and `libcrypto` (from OpenSSL) and make sure that the directories containing `nomicle.h` and the OpenSSL headers are included in your header search paths. How to do this will vary depending on how you're writing your code (using an IDE, a text editor and the command line, etc.)

### Example (C code)

```c
#include <nomicle.h>
#include <stdio.h>

int main(int argc, const char *argv[])
{
    EVP_PKEY *private_key = NULL;
    key_fetch("/usr/local/etc/ncle/privkey.pem", &private_key);

    struct nomicle *id = NULL;
    /* REPLACE PATH WITH ONE TO AN ACTUAL BLOCK ON YOUR SYSTEM! */
    block_read("/usr/local/var/ncle/blocks/48508b092dfa59c4d9d8f6423c9f17935295641363f86c163a0ee580489393c4.ncle", &id);
    return 0;
}
```

This is a simple example that demonstrates how to fetch the user's Nomicle private key as well as how to load a nomicle from the disk into a data structure you can use. For a more comprehensive example, take a look at the `test` directory inside the `libcnomicle` project.

### Data Type: `struct nomicle`

- `uint32_t bits`: The calculated difficulty target being used for this identity stored in compact form.
- `uint64_t extra_nonce`: Used in case `nonce` overflows.
- `unsigned char hash[NCLE_CHECKSUM_LEN]`: First NCLE_CHECKSUM_LEN (currently defined as **8**) bytes of the SHA256 checksum of the block. To verify the hash, use the `hash()` function and compare against the first 8 bytes from the checksum it computes.
- `uint64_t nonce`: A counter to be incremented for varying the block's hash when solving the proof-of-work.
- `EVP_PKEY *pub_key`: The public key of the owner; can be verified by the signature.
- `ECDSA_SIG *sig`: The signature of the full `hash` generated by the private key that owns this identity.
- `int64_t timestamp_created`: Unix timestamp as seconds since 1970-01-01T00:00 UTC until the time that this identity was created.
- `int64_t timestamp_updated`: Unix timestamp as seconds since 1970-01-01T00:00 UTC until the time that this identity was last updated.
- `unsigned char token[NCLE_TOKEN_LEN]`: The identity token hash. This is a SHA256 hexadecimal string.
- `uint8_t version`: The identity version number that this nomicle conforms to.

**For most intents and purposes, the members of interest to most developers working with nomicles will be `pub_key` and `token`.**

### Library Functions

#### `void id_free(struct nomicle **id)`

Frees the memory held by `id`. If you used `id_init()` to initialise a nomicle, you need to call this function to free the memory held by that nomicle.

#### `void id_init(const char *identifier, EVP_PKEY *pub_key, struct nomicle **id)`

Initialises a nomicle in `id`. `identifier` is the string (in its plain text format; typically as chosen by the user) that this nomicle will be associated with.

`pub_key` can be a secp256k1 elliptic curve key of type [EVP_PKEY*](https://wiki.openssl.org/index.php/EVP) and will be the public key associated with the identifier in this nomicle.

Make sure to call `id_free()` once you're done with the structure to free up its memory.

#### `int blockcmp(const struct nomicle *block1, const struct nomicle *block2)`

Can be used to compare the targets of two blocks. Returns 0 if both blocks were solved for the same difficulty, 1 if `block2` was solved for a higher difficulty than `block1`, or -1 if `block1` was solved for a higher difficulty than `block2`.

#### `void block_deserialise(const unsigned char *bytes, size_t len, struct nomicle **id)`

Deserialises the bytes in `bytes` into a `nomicle` structure in `id`. `len` should be the length of the byte array in `bytes`.

#### `void block_dump(struct nomicle *id, const char *path, EVP_PKEY *priv_key)`

Saves the nomicle to the disk location specified in `path`. If `priv_key` is set to a secp256k1 elliptic curve private key of type [EVP_PKEY*](https://wiki.openssl.org/index.php/EVP), that key will be used to sign the nomicle before dumping it to the disk.

#### `int block_read(const char *path, struct nomicle **id)`

Reads the nomicle file at the disk location specified in `path`, initialises a `nomicle` structure with it, and sets a pointer in `id` to the new structure. Returns 0 if the block was read and serialised successfully, 1 if the block was read but serialisation failed, or -1 if an error occured while attempting to read the file at the given path.

#### `size_t block_serialise(struct nomicle *id, unsigned char **bytes_out, EVP_PKEY *priv_key)`

Serialises a nomicle into a byte array pointed to in `bytes_out` (remember to `free()` this variable once you're done with it). If `priv_key` is set to a secp256k1 elliptic curve private key of type [EVP_PKEY*](https://wiki.openssl.org/index.php/EVP), that key will be used to sign the nomicle and the signature will be included in the array. Returns the length of `bytes_out`.

#### `void crypto_init(void)`

Initializes the cryptographic subsystem. This function must be called before using any other functions in the library.
